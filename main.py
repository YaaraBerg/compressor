from typing import List, Tuple
import os
from bitarray import bitarray

def main() -> None:
    # List of sample files to process
    sample_files = ["Samp1.bin", "Samp2.bin", "Samp3.bin", "Samp4.bin"]

    for filename in sample_files:
        if os.path.exists(filename):
            output_filename = f"compressed_{filename}"
            decoded_filename = f"decoded_{filename}"
            encoder(filename, output_filename)
            decoder(output_filename, decoded_filename)

            # Verify that decoder(encoder(X)) = X
            with open(filename, 'rb') as f:
                original_data = f.read()
            with open(decoded_filename, 'rb') as f:
                decoded_data = f.read()

            assert original_data == decoded_data, f"Assertion failed for {filename}: decoder(encoder(X)) != X"


def lampel_ziv(data: bitarray) -> List[Tuple[int, int, int]]:
    """
    Performs Lempel-Ziv (LZ77) compression on a binary array.

    Args:
        data (bitarray): The input binary data to be compressed.

    Returns:
        List[Tuple[int, int, int]]: A list of tuples representing the compressed data.
        Each tuple typically contains (offset, length, next_symbol).
    """
    pass


def convert_lampel_ziv_list_to_binarray(lz_list: List[Tuple[int, int, int]]) -> bitarray:
    """
    Converts a list of Lempel-Ziv tuples back into a binary array format.

    Args:
        lz_list (List[Tuple[int, int, int]]): The list of LZ tuples
        (offset, length, next_symbol) generated by the compression algorithm.

    Returns:
        bitarray: The reconstructed binary data derived from the tuples.
    """
    pass


def convert_binarray_to_lampel_ziv_list(data: bitarray) -> List[Tuple[int, int, int]]:
    """
    Converts a into a binary array to list of Lempel-Ziv tuples.

    Args:
        data (bitarray): The input binary data to be compressed.
        (offset, length, next_symbol) generated by the compression algorithm.

    Returns:
        lz_list (List[Tuple[int, int, int]]): The list of LZ tuples
    """
    pass

def encoder(input_path: str, output_path: str) -> None:
    """
    Reads a file from the input path, compresses it using Lempel-Ziv,
    and saves the result to the output path.

    Args:
        input_path (str): The file path of the source file to compress.
        output_path (str): The destination file path where the compressed
        data will be saved.

    Returns:
        None
    """
    # Read the input file as binary data
    with open(input_path, 'rb') as f:
        data = f.read()

    # Convert bytes to bitarray
    bit_data = bitarray()
    bit_data.frombytes(data)

    # Very basic encoding: just save file size info for now
    # In a real implementation, you would use the lampel_ziv function
    file_size = len(data)

    # Simple encoding: prepend file size and save
    with open(output_path, 'wb') as f:
        f.write(file_size.to_bytes(4, byteorder='big'))  # Write file size as 4 bytes
        f.write(bit_data.tobytes())  # Write original data (this is just a placeholder)


def decoder(input_path: str, output_path: str) -> None:
    """
    Reads a compressed file from the input path, decodes it,
    and saves the reconstructed data to the output path.

    Args:
        input_path (str): The file path of the compressed file to read.
        output_path (str): The destination file path where the decompressed
        (original) data will be saved.

    Returns:
        None
    """
    # Read the compressed file
    with open(input_path, 'rb') as f:
        # Read the file size (first 4 bytes)
        file_size_bytes = f.read(4)
        file_size = int.from_bytes(file_size_bytes, byteorder='big')

        # Read the actual data
        data = f.read(file_size)

    # Write the decoded data to output file
    with open(output_path, 'wb') as f:
        f.write(data)


if __name__ == "__main__":
    main()
