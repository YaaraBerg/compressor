from typing import List, Tuple
from bitarray import bitarray


def basic_lempel_ziv(data: bitarray, search_length: int, match_length: int, **kwargs) -> List[Tuple[int, int, bitarray]]:
    """
    Performs basic Lempel-Ziv compression on a bitarray

    Args:
        data (bitarray): The input binary data to be compressed
        search_length (int): The maximum length of the search buffer
        match_length (int): The maximum length of a matching substring

    Returns:
        List[Tuple[int, int, bitarray]]: A list of tuples representing the compressed data.
        Each tuple contains (offset_bytes, length_bytes, next_byte_bits).
    """
    byte_count = len(data) // 8
    result = []
    i = 0

    while i < byte_count:
        best_offset = 0
        best_length = 0

        # Search for the longest match in the previous data
        for j in range(max(0, i - search_length), i):
            length = 0
            while (length < match_length and i + length < byte_count - 1 and
                   data[(j + length)*8:(j + length + 1)*8] == data[(i + length)*8:(i + length + 1)*8]):
                length += 1

            if length > best_length:
                best_length = length
                best_offset = i - j

        # Next byte after the match
        next_byte = data[(i + best_length)*8:(i + best_length + 1)*8]

        # Append the tuple (offset_bytes, length_bytes, next_byte_bits)
        result.append((best_offset, best_length, next_byte))

        # Move the index forward
        i += best_length + 1

    return result


def convert_lampel_ziv_list_to_binarray(lz_list: List[Tuple[int, int, bitarray]]) -> bitarray:
    """
    Converts a list of Lempel-Ziv tuples back into a bitarray format

    Args:
        lz_list (List[Tuple[int, int, bitarray]]): The list of LZ tuples
        (offset_bytes, length_bytes, next_byte_bits) generated by the compression algorithm.

    Returns:
        bitarray: The reconstructed binary data derived from the tuples.
    """
    result = bitarray()

    for offset, length, next_byte in lz_list:
        current_byte_count = len(result) // 8
        for i in range(length):
            source_byte_index = current_byte_count - offset + i
            source_byte_bits = result[source_byte_index*8:(source_byte_index+1)*8]
            result.extend(source_byte_bits)

        # Append the next byte
        result.extend(next_byte)

    return result
